{"version":3,"file":"render.js","sources":["node_modules/.pnpm/svelte@4.2.9/node_modules/svelte/src/runtime/internal/utils.js","node_modules/.pnpm/svelte@4.2.9/node_modules/svelte/src/runtime/internal/lifecycle.js","node_modules/.pnpm/svelte@4.2.9/node_modules/svelte/src/runtime/internal/ssr.js","node_modules/.pnpm/golte@0.0.3_svelte@4.2.9/node_modules/golte/js/shared/Node.svelte","node_modules/.pnpm/golte@0.0.3_svelte@4.2.9/node_modules/golte/js/shared/keys.js","node_modules/.pnpm/golte@0.0.3_svelte@4.2.9/node_modules/golte/js/shared/node-wrapper.js","node_modules/.pnpm/svelte@4.2.9/node_modules/svelte/src/runtime/store/index.js","node_modules/.pnpm/golte@0.0.3_svelte@4.2.9/node_modules/golte/js/shared/list.js","node_modules/.pnpm/golte@0.0.3_svelte@4.2.9/node_modules/golte/js/shared/appstate.js","node_modules/.pnpm/golte@0.0.3_svelte@4.2.9/node_modules/golte/js/shared/Root.svelte","node_modules/.pnpm/golte@0.0.3_svelte@4.2.9/node_modules/golte/js/public/stores/index.js","web/layout/main.svelte","web/page/profile.svelte","node_modules/.pnpm/golte@0.0.3_svelte@4.2.9/node_modules/golte/js/shared/default-error.svelte","node_modules/.pnpm/golte@0.0.3_svelte@4.2.9/node_modules/golte/js/server/render.js"],"sourcesContent":["/** @returns {void} */\nexport function noop() {}\n\nexport const identity = (x) => x;\n\n/**\n * @template T\n * @template S\n * @param {T} tar\n * @param {S} src\n * @returns {T & S}\n */\nexport function assign(tar, src) {\n\t// @ts-ignore\n\tfor (const k in src) tar[k] = src[k];\n\treturn /** @type {T & S} */ (tar);\n}\n\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\n/**\n * @param {any} value\n * @returns {value is PromiseLike<any>}\n */\nexport function is_promise(value) {\n\treturn (\n\t\t!!value &&\n\t\t(typeof value === 'object' || typeof value === 'function') &&\n\t\ttypeof (/** @type {any} */ (value).then) === 'function'\n\t);\n}\n\n/** @returns {void} */\nexport function add_location(element, file, line, column, char) {\n\telement.__svelte_meta = {\n\t\tloc: { file, line, column, char }\n\t};\n}\n\nexport function run(fn) {\n\treturn fn();\n}\n\nexport function blank_object() {\n\treturn Object.create(null);\n}\n\n/**\n * @param {Function[]} fns\n * @returns {void}\n */\nexport function run_all(fns) {\n\tfns.forEach(run);\n}\n\n/**\n * @param {any} thing\n * @returns {thing is Function}\n */\nexport function is_function(thing) {\n\treturn typeof thing === 'function';\n}\n\n/** @returns {boolean} */\nexport function safe_not_equal(a, b) {\n\treturn a != a ? b == b : a !== b || (a && typeof a === 'object') || typeof a === 'function';\n}\n\nlet src_url_equal_anchor;\n\n/**\n * @param {string} element_src\n * @param {string} url\n * @returns {boolean}\n */\nexport function src_url_equal(element_src, url) {\n\tif (element_src === url) return true;\n\tif (!src_url_equal_anchor) {\n\t\tsrc_url_equal_anchor = document.createElement('a');\n\t}\n\t// This is actually faster than doing URL(..).href\n\tsrc_url_equal_anchor.href = url;\n\treturn element_src === src_url_equal_anchor.href;\n}\n\n/** @param {string} srcset */\nfunction split_srcset(srcset) {\n\treturn srcset.split(',').map((src) => src.trim().split(' ').filter(Boolean));\n}\n\n/**\n * @param {HTMLSourceElement | HTMLImageElement} element_srcset\n * @param {string | undefined | null} srcset\n * @returns {boolean}\n */\nexport function srcset_url_equal(element_srcset, srcset) {\n\tconst element_urls = split_srcset(element_srcset.srcset);\n\tconst urls = split_srcset(srcset || '');\n\n\treturn (\n\t\turls.length === element_urls.length &&\n\t\turls.every(\n\t\t\t([url, width], i) =>\n\t\t\t\twidth === element_urls[i][1] &&\n\t\t\t\t// We need to test both ways because Vite will create an a full URL with\n\t\t\t\t// `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the\n\t\t\t\t// relative URLs inside srcset are not automatically resolved to absolute URLs by\n\t\t\t\t// browsers (in contrast to img.src). This means both SSR and DOM code could\n\t\t\t\t// contain relative or absolute URLs.\n\t\t\t\t(src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))\n\t\t)\n\t);\n}\n\n/** @returns {boolean} */\nexport function not_equal(a, b) {\n\treturn a != a ? b == b : a !== b;\n}\n\n/** @returns {boolean} */\nexport function is_empty(obj) {\n\treturn Object.keys(obj).length === 0;\n}\n\n/** @returns {void} */\nexport function validate_store(store, name) {\n\tif (store != null && typeof store.subscribe !== 'function') {\n\t\tthrow new Error(`'${name}' is not a store with a 'subscribe' method`);\n\t}\n}\n\nexport function subscribe(store, ...callbacks) {\n\tif (store == null) {\n\t\tfor (const callback of callbacks) {\n\t\t\tcallback(undefined);\n\t\t}\n\t\treturn noop;\n\t}\n\tconst unsub = store.subscribe(...callbacks);\n\treturn unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\n\n/**\n * Get the current value from a store by subscribing and immediately unsubscribing.\n *\n * https://svelte.dev/docs/svelte-store#get\n * @template T\n * @param {import('../store/public.js').Readable<T>} store\n * @returns {T}\n */\nexport function get_store_value(store) {\n\tlet value;\n\tsubscribe(store, (_) => (value = _))();\n\treturn value;\n}\n\n/** @returns {void} */\nexport function component_subscribe(component, store, callback) {\n\tcomponent.$$.on_destroy.push(subscribe(store, callback));\n}\n\nexport function create_slot(definition, ctx, $$scope, fn) {\n\tif (definition) {\n\t\tconst slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n\t\treturn definition[0](slot_ctx);\n\t}\n}\n\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n\treturn definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\n\nexport function get_slot_changes(definition, $$scope, dirty, fn) {\n\tif (definition[2] && fn) {\n\t\tconst lets = definition[2](fn(dirty));\n\t\tif ($$scope.dirty === undefined) {\n\t\t\treturn lets;\n\t\t}\n\t\tif (typeof lets === 'object') {\n\t\t\tconst merged = [];\n\t\t\tconst len = Math.max($$scope.dirty.length, lets.length);\n\t\t\tfor (let i = 0; i < len; i += 1) {\n\t\t\t\tmerged[i] = $$scope.dirty[i] | lets[i];\n\t\t\t}\n\t\t\treturn merged;\n\t\t}\n\t\treturn $$scope.dirty | lets;\n\t}\n\treturn $$scope.dirty;\n}\n\n/** @returns {void} */\nexport function update_slot_base(\n\tslot,\n\tslot_definition,\n\tctx,\n\t$$scope,\n\tslot_changes,\n\tget_slot_context_fn\n) {\n\tif (slot_changes) {\n\t\tconst slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n\t\tslot.p(slot_context, slot_changes);\n\t}\n}\n\n/** @returns {void} */\nexport function update_slot(\n\tslot,\n\tslot_definition,\n\tctx,\n\t$$scope,\n\tdirty,\n\tget_slot_changes_fn,\n\tget_slot_context_fn\n) {\n\tconst slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n\tupdate_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\n\n/** @returns {any[] | -1} */\nexport function get_all_dirty_from_scope($$scope) {\n\tif ($$scope.ctx.length > 32) {\n\t\tconst dirty = [];\n\t\tconst length = $$scope.ctx.length / 32;\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tdirty[i] = -1;\n\t\t}\n\t\treturn dirty;\n\t}\n\treturn -1;\n}\n\n/** @returns {{}} */\nexport function exclude_internal_props(props) {\n\tconst result = {};\n\tfor (const k in props) if (k[0] !== '$') result[k] = props[k];\n\treturn result;\n}\n\n/** @returns {{}} */\nexport function compute_rest_props(props, keys) {\n\tconst rest = {};\n\tkeys = new Set(keys);\n\tfor (const k in props) if (!keys.has(k) && k[0] !== '$') rest[k] = props[k];\n\treturn rest;\n}\n\n/** @returns {{}} */\nexport function compute_slots(slots) {\n\tconst result = {};\n\tfor (const key in slots) {\n\t\tresult[key] = true;\n\t}\n\treturn result;\n}\n\n/** @returns {(this: any, ...args: any[]) => void} */\nexport function once(fn) {\n\tlet ran = false;\n\treturn function (...args) {\n\t\tif (ran) return;\n\t\tran = true;\n\t\tfn.call(this, ...args);\n\t};\n}\n\nexport function null_to_empty(value) {\n\treturn value == null ? '' : value;\n}\n\nexport function set_store_value(store, ret, value) {\n\tstore.set(value);\n\treturn ret;\n}\n\nexport const has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n\nexport function action_destroyer(action_result) {\n\treturn action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\n/** @param {number | string} value\n * @returns {[number, string]}\n */\nexport function split_css_unit(value) {\n\tconst split = typeof value === 'string' && value.match(/^\\s*(-?[\\d.]+)([^\\s]*)\\s*$/);\n\treturn split ? [parseFloat(split[1]), split[2] || 'px'] : [/** @type {number} */ (value), 'px'];\n}\n\nexport const contenteditable_truthy_values = ['', true, 1, 'true', 'contenteditable'];\n","import { custom_event } from './dom.js';\n\nexport let current_component;\n\n/** @returns {void} */\nexport function set_current_component(component) {\n\tcurrent_component = component;\n}\n\nexport function get_current_component() {\n\tif (!current_component) throw new Error('Function called outside component initialization');\n\treturn current_component;\n}\n\n/**\n * Schedules a callback to run immediately before the component is updated after any state change.\n *\n * The first time the callback runs will be before the initial `onMount`\n *\n * https://svelte.dev/docs/svelte#beforeupdate\n * @param {() => any} fn\n * @returns {void}\n */\nexport function beforeUpdate(fn) {\n\tget_current_component().$$.before_update.push(fn);\n}\n\n/**\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n * it can be called from an external module).\n *\n * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.\n *\n * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).\n *\n * https://svelte.dev/docs/svelte#onmount\n * @template T\n * @param {() => import('./private.js').NotFunction<T> | Promise<import('./private.js').NotFunction<T>> | (() => any)} fn\n * @returns {void}\n */\nexport function onMount(fn) {\n\tget_current_component().$$.on_mount.push(fn);\n}\n\n/**\n * Schedules a callback to run immediately after the component has been updated.\n *\n * The first time the callback runs will be after the initial `onMount`\n *\n * https://svelte.dev/docs/svelte#afterupdate\n * @param {() => any} fn\n * @returns {void}\n */\nexport function afterUpdate(fn) {\n\tget_current_component().$$.after_update.push(fn);\n}\n\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * https://svelte.dev/docs/svelte#ondestroy\n * @param {() => any} fn\n * @returns {void}\n */\nexport function onDestroy(fn) {\n\tget_current_component().$$.on_destroy.push(fn);\n}\n\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:\n * ```ts\n * const dispatch = createEventDispatcher<{\n *  loaded: never; // does not take a detail argument\n *  change: string; // takes a detail argument of type string, which is required\n *  optional: number | null; // takes an optional detail argument of type number\n * }>();\n * ```\n *\n * https://svelte.dev/docs/svelte#createeventdispatcher\n * @template {Record<string, any>} [EventMap=any]\n * @returns {import('./public.js').EventDispatcher<EventMap>}\n */\nexport function createEventDispatcher() {\n\tconst component = get_current_component();\n\treturn (type, detail, { cancelable = false } = {}) => {\n\t\tconst callbacks = component.$$.callbacks[type];\n\t\tif (callbacks) {\n\t\t\t// TODO are there situations where events could be dispatched\n\t\t\t// in a server (non-DOM) environment?\n\t\t\tconst event = custom_event(/** @type {string} */ (type), detail, { cancelable });\n\t\t\tcallbacks.slice().forEach((fn) => {\n\t\t\t\tfn.call(component, event);\n\t\t\t});\n\t\t\treturn !event.defaultPrevented;\n\t\t}\n\t\treturn true;\n\t};\n}\n\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#setcontext\n * @template T\n * @param {any} key\n * @param {T} context\n * @returns {T}\n */\nexport function setContext(key, context) {\n\tget_current_component().$$.context.set(key, context);\n\treturn context;\n}\n\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#getcontext\n * @template T\n * @param {any} key\n * @returns {T}\n */\nexport function getContext(key) {\n\treturn get_current_component().$$.context.get(key);\n}\n\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * https://svelte.dev/docs/svelte#getallcontexts\n * @template {Map<any, any>} [T=Map<any, any>]\n * @returns {T}\n */\nexport function getAllContexts() {\n\treturn get_current_component().$$.context;\n}\n\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#hascontext\n * @param {any} key\n * @returns {boolean}\n */\nexport function hasContext(key) {\n\treturn get_current_component().$$.context.has(key);\n}\n\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\n/**\n * @param component\n * @param event\n * @returns {void}\n */\nexport function bubble(component, event) {\n\tconst callbacks = component.$$.callbacks[event.type];\n\tif (callbacks) {\n\t\t// @ts-ignore\n\t\tcallbacks.slice().forEach((fn) => fn.call(this, event));\n\t}\n}\n","import { set_current_component, current_component } from './lifecycle.js';\nimport { run_all, blank_object } from './utils.js';\nimport { boolean_attributes } from '../../shared/boolean_attributes.js';\nimport { ensure_array_like } from './each.js';\nexport { is_void } from '../../shared/utils/names.js';\n\nexport const invalid_attribute_name_character =\n\t/[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\n\n/** @returns {string} */\nexport function spread(args, attrs_to_add) {\n\tconst attributes = Object.assign({}, ...args);\n\tif (attrs_to_add) {\n\t\tconst classes_to_add = attrs_to_add.classes;\n\t\tconst styles_to_add = attrs_to_add.styles;\n\t\tif (classes_to_add) {\n\t\t\tif (attributes.class == null) {\n\t\t\t\tattributes.class = classes_to_add;\n\t\t\t} else {\n\t\t\t\tattributes.class += ' ' + classes_to_add;\n\t\t\t}\n\t\t}\n\t\tif (styles_to_add) {\n\t\t\tif (attributes.style == null) {\n\t\t\t\tattributes.style = style_object_to_string(styles_to_add);\n\t\t\t} else {\n\t\t\t\tattributes.style = style_object_to_string(\n\t\t\t\t\tmerge_ssr_styles(attributes.style, styles_to_add)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\tlet str = '';\n\tObject.keys(attributes).forEach((name) => {\n\t\tif (invalid_attribute_name_character.test(name)) return;\n\t\tconst value = attributes[name];\n\t\tif (value === true) str += ' ' + name;\n\t\telse if (boolean_attributes.has(name.toLowerCase())) {\n\t\t\tif (value) str += ' ' + name;\n\t\t} else if (value != null) {\n\t\t\tstr += ` ${name}=\"${value}\"`;\n\t\t}\n\t});\n\treturn str;\n}\n\n/** @returns {{}} */\nexport function merge_ssr_styles(style_attribute, style_directive) {\n\tconst style_object = {};\n\tfor (const individual_style of style_attribute.split(';')) {\n\t\tconst colon_index = individual_style.indexOf(':');\n\t\tconst name = individual_style.slice(0, colon_index).trim();\n\t\tconst value = individual_style.slice(colon_index + 1).trim();\n\t\tif (!name) continue;\n\t\tstyle_object[name] = value;\n\t}\n\tfor (const name in style_directive) {\n\t\tconst value = style_directive[name];\n\t\tif (value) {\n\t\t\tstyle_object[name] = value;\n\t\t} else {\n\t\t\tdelete style_object[name];\n\t\t}\n\t}\n\treturn style_object;\n}\n\nconst ATTR_REGEX = /[&\"]/g;\nconst CONTENT_REGEX = /[&<]/g;\n\n/**\n * Note: this method is performance sensitive and has been optimized\n * https://github.com/sveltejs/svelte/pull/5701\n * @param {unknown} value\n * @returns {string}\n */\nexport function escape(value, is_attr = false) {\n\tconst str = String(value);\n\tconst pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;\n\tpattern.lastIndex = 0;\n\tlet escaped = '';\n\tlet last = 0;\n\twhile (pattern.test(str)) {\n\t\tconst i = pattern.lastIndex - 1;\n\t\tconst ch = str[i];\n\t\tescaped += str.substring(last, i) + (ch === '&' ? '&amp;' : ch === '\"' ? '&quot;' : '&lt;');\n\t\tlast = i + 1;\n\t}\n\treturn escaped + str.substring(last);\n}\n\nexport function escape_attribute_value(value) {\n\t// keep booleans, null, and undefined for the sake of `spread`\n\tconst should_escape = typeof value === 'string' || (value && typeof value === 'object');\n\treturn should_escape ? escape(value, true) : value;\n}\n\n/** @returns {{}} */\nexport function escape_object(obj) {\n\tconst result = {};\n\tfor (const key in obj) {\n\t\tresult[key] = escape_attribute_value(obj[key]);\n\t}\n\treturn result;\n}\n\n/** @returns {string} */\nexport function each(items, fn) {\n\titems = ensure_array_like(items);\n\tlet str = '';\n\tfor (let i = 0; i < items.length; i += 1) {\n\t\tstr += fn(items[i], i);\n\t}\n\treturn str;\n}\n\nexport const missing_component = {\n\t$$render: () => ''\n};\n\nexport function validate_component(component, name) {\n\tif (!component || !component.$$render) {\n\t\tif (name === 'svelte:component') name += ' this={...}';\n\t\tthrow new Error(\n\t\t\t`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules. Otherwise you may need to fix a <${name}>.`\n\t\t);\n\t}\n\treturn component;\n}\n\n/** @returns {string} */\nexport function debug(file, line, column, values) {\n\tconsole.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n\tconsole.log(values); // eslint-disable-line no-console\n\treturn '';\n}\n\nlet on_destroy;\n\n/** @returns {{ render: (props?: {}, { $$slots, context }?: { $$slots?: {}; context?: Map<any, any>; }) => { html: any; css: { code: string; map: any; }; head: string; }; $$render: (result: any, props: any, bindings: any, slots: any, context: any) => any; }} */\nexport function create_ssr_component(fn) {\n\tfunction $$render(result, props, bindings, slots, context) {\n\t\tconst parent_component = current_component;\n\t\tconst $$ = {\n\t\t\ton_destroy,\n\t\t\tcontext: new Map(context || (parent_component ? parent_component.$$.context : [])),\n\t\t\t// these will be immediately discarded\n\t\t\ton_mount: [],\n\t\t\tbefore_update: [],\n\t\t\tafter_update: [],\n\t\t\tcallbacks: blank_object()\n\t\t};\n\t\tset_current_component({ $$ });\n\t\tconst html = fn(result, props, bindings, slots);\n\t\tset_current_component(parent_component);\n\t\treturn html;\n\t}\n\treturn {\n\t\trender: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n\t\t\ton_destroy = [];\n\t\t\tconst result = { title: '', head: '', css: new Set() };\n\t\t\tconst html = $$render(result, props, {}, $$slots, context);\n\t\t\trun_all(on_destroy);\n\t\t\treturn {\n\t\t\t\thtml,\n\t\t\t\tcss: {\n\t\t\t\t\tcode: Array.from(result.css)\n\t\t\t\t\t\t.map((css) => css.code)\n\t\t\t\t\t\t.join('\\n'),\n\t\t\t\t\tmap: null // TODO\n\t\t\t\t},\n\t\t\t\thead: result.title + result.head\n\t\t\t};\n\t\t},\n\t\t$$render\n\t};\n}\n\n/** @returns {string} */\nexport function add_attribute(name, value, boolean) {\n\tif (value == null || (boolean && !value)) return '';\n\tconst assignment = boolean && value === true ? '' : `=\"${escape(value, true)}\"`;\n\treturn ` ${name}${assignment}`;\n}\n\n/** @returns {string} */\nexport function add_classes(classes) {\n\treturn classes ? ` class=\"${classes}\"` : '';\n}\n\n/** @returns {string} */\nfunction style_object_to_string(style_object) {\n\treturn Object.keys(style_object)\n\t\t.filter((key) => style_object[key])\n\t\t.map((key) => `${key}: ${escape_attribute_value(style_object[key])};`)\n\t\t.join(' ');\n}\n\n/** @returns {string} */\nexport function add_styles(style_object) {\n\tconst styles = style_object_to_string(style_object);\n\treturn styles ? ` style=\"${styles}\"` : '';\n}\n","<!-- Do not import this directly; instead import node-wrapper.js -->\n\n<script>\n\timport { Node } from \"./node-wrapper.js\";\n\n\t/** @type {import(\"./list.js\").ListNode<import(\"./types.js\").CompState>} */\n\texport let node;\n\t\n\t/** @type {number} */\n\texport let index;\n\n\tconst { next, content } = node;\n</script>\n\n<svelte:component this={content.comp} {...content.props}>\n\t<!-- #key is needed because csr error handling relies on constructor being called again -->\n\t{#key $next}\n\t\t{#if $next}\n\t\t\t<!-- Cannot use svelte:self because need to use wrapper -->\n\t\t\t<Node node={$next} index={index + 1} />\n\t\t{/if}\n\t{/key}\n</svelte:component>\n","export const golteContext = Symbol();\nexport const handleError = Symbol();\n//# sourceMappingURL=keys.js.map","// This file is a wrapper for Node.svelte that adds functionality handling errors.\n// When an error is thrown during ssr, it catches it and instead\n// the specified error page is rendered instead.\nimport { default as ClientNode } from \"./Node.svelte\";\nimport { getContext } from \"svelte\";\nimport { handleError } from \"./keys.js\";\nconst ServerNode = ClientNode;\nconst ssrWrapper = {\n    ...ServerNode,\n    $$render: (result, props, bindings, slots, context) => {\n        try {\n            return ServerNode.$$render(result, props, bindings, slots, context);\n        }\n        catch (err) {\n            let message = \"Internal Error\";\n            if (import.meta.env.MODE === \"development\") {\n                message = (err instanceof Error && err.stack) ? err.stack : String(err);\n            }\n            const errProps = {\n                status: 500,\n                message,\n            };\n            getContext(handleError)({ index: props.index, props: errProps });\n            return props.node.content.errPage.$$render(result, errProps, bindings, slots, context);\n        }\n    }\n};\nfunction csrWrapper(options) {\n    // if there as an error during ssr, don't render anything new\n    const ssrError = options.props.node.content.ssrError;\n    if (ssrError)\n        return new options.props.node.content.errPage({ ...options, props: ssrError });\n    return new ClientNode(options);\n}\n;\nexport const Node = import.meta.env.SSR ? ssrWrapper : csrWrapper;\n//# sourceMappingURL=node-wrapper.js.map","import {\n\trun_all,\n\tsubscribe,\n\tnoop,\n\tsafe_not_equal,\n\tis_function,\n\tget_store_value\n} from '../internal/index.js';\n\nconst subscriber_queue = [];\n\n/**\n * Creates a `Readable` store that allows reading by subscription.\n *\n * https://svelte.dev/docs/svelte-store#readable\n * @template T\n * @param {T} [value] initial value\n * @param {import('./public.js').StartStopNotifier<T>} [start]\n * @returns {import('./public.js').Readable<T>}\n */\nexport function readable(value, start) {\n\treturn {\n\t\tsubscribe: writable(value, start).subscribe\n\t};\n}\n\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n *\n * https://svelte.dev/docs/svelte-store#writable\n * @template T\n * @param {T} [value] initial value\n * @param {import('./public.js').StartStopNotifier<T>} [start]\n * @returns {import('./public.js').Writable<T>}\n */\nexport function writable(value, start = noop) {\n\t/** @type {import('./public.js').Unsubscriber} */\n\tlet stop;\n\t/** @type {Set<import('./private.js').SubscribeInvalidateTuple<T>>} */\n\tconst subscribers = new Set();\n\t/** @param {T} new_value\n\t * @returns {void}\n\t */\n\tfunction set(new_value) {\n\t\tif (safe_not_equal(value, new_value)) {\n\t\t\tvalue = new_value;\n\t\t\tif (stop) {\n\t\t\t\t// store is ready\n\t\t\t\tconst run_queue = !subscriber_queue.length;\n\t\t\t\tfor (const subscriber of subscribers) {\n\t\t\t\t\tsubscriber[1]();\n\t\t\t\t\tsubscriber_queue.push(subscriber, value);\n\t\t\t\t}\n\t\t\t\tif (run_queue) {\n\t\t\t\t\tfor (let i = 0; i < subscriber_queue.length; i += 2) {\n\t\t\t\t\t\tsubscriber_queue[i][0](subscriber_queue[i + 1]);\n\t\t\t\t\t}\n\t\t\t\t\tsubscriber_queue.length = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {import('./public.js').Updater<T>} fn\n\t * @returns {void}\n\t */\n\tfunction update(fn) {\n\t\tset(fn(value));\n\t}\n\n\t/**\n\t * @param {import('./public.js').Subscriber<T>} run\n\t * @param {import('./private.js').Invalidator<T>} [invalidate]\n\t * @returns {import('./public.js').Unsubscriber}\n\t */\n\tfunction subscribe(run, invalidate = noop) {\n\t\t/** @type {import('./private.js').SubscribeInvalidateTuple<T>} */\n\t\tconst subscriber = [run, invalidate];\n\t\tsubscribers.add(subscriber);\n\t\tif (subscribers.size === 1) {\n\t\t\tstop = start(set, update) || noop;\n\t\t}\n\t\trun(value);\n\t\treturn () => {\n\t\t\tsubscribers.delete(subscriber);\n\t\t\tif (subscribers.size === 0 && stop) {\n\t\t\t\tstop();\n\t\t\t\tstop = null;\n\t\t\t}\n\t\t};\n\t}\n\treturn { set, update, subscribe };\n}\n\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * https://svelte.dev/docs/svelte-store#derived\n * @template {import('./private.js').Stores} S\n * @template T\n * @overload\n * @param {S} stores - input stores\n * @param {(values: import('./private.js').StoresValues<S>, set: (value: T) => void, update: (fn: import('./public.js').Updater<T>) => void) => import('./public.js').Unsubscriber | void} fn - function callback that aggregates the values\n * @param {T} [initial_value] - initial value\n * @returns {import('./public.js').Readable<T>}\n */\n\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * https://svelte.dev/docs/svelte-store#derived\n * @template {import('./private.js').Stores} S\n * @template T\n * @overload\n * @param {S} stores - input stores\n * @param {(values: import('./private.js').StoresValues<S>) => T} fn - function callback that aggregates the values\n * @param {T} [initial_value] - initial value\n * @returns {import('./public.js').Readable<T>}\n */\n\n/**\n * @template {import('./private.js').Stores} S\n * @template T\n * @param {S} stores\n * @param {Function} fn\n * @param {T} [initial_value]\n * @returns {import('./public.js').Readable<T>}\n */\nexport function derived(stores, fn, initial_value) {\n\tconst single = !Array.isArray(stores);\n\t/** @type {Array<import('./public.js').Readable<any>>} */\n\tconst stores_array = single ? [stores] : stores;\n\tif (!stores_array.every(Boolean)) {\n\t\tthrow new Error('derived() expects stores as input, got a falsy value');\n\t}\n\tconst auto = fn.length < 2;\n\treturn readable(initial_value, (set, update) => {\n\t\tlet started = false;\n\t\tconst values = [];\n\t\tlet pending = 0;\n\t\tlet cleanup = noop;\n\t\tconst sync = () => {\n\t\t\tif (pending) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcleanup();\n\t\t\tconst result = fn(single ? values[0] : values, set, update);\n\t\t\tif (auto) {\n\t\t\t\tset(result);\n\t\t\t} else {\n\t\t\t\tcleanup = is_function(result) ? result : noop;\n\t\t\t}\n\t\t};\n\t\tconst unsubscribers = stores_array.map((store, i) =>\n\t\t\tsubscribe(\n\t\t\t\tstore,\n\t\t\t\t(value) => {\n\t\t\t\t\tvalues[i] = value;\n\t\t\t\t\tpending &= ~(1 << i);\n\t\t\t\t\tif (started) {\n\t\t\t\t\t\tsync();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t() => {\n\t\t\t\t\tpending |= 1 << i;\n\t\t\t\t}\n\t\t\t)\n\t\t);\n\t\tstarted = true;\n\t\tsync();\n\t\treturn function stop() {\n\t\t\trun_all(unsubscribers);\n\t\t\tcleanup();\n\t\t\t// We need to set this to false because callbacks can still happen despite having unsubscribed:\n\t\t\t// Callbacks might already be placed in the queue which doesn't know it should no longer\n\t\t\t// invoke this derived store.\n\t\t\tstarted = false;\n\t\t};\n\t});\n}\n\n/**\n * Takes a store and returns a new one derived from the old one that is readable.\n *\n * https://svelte.dev/docs/svelte-store#readonly\n * @template T\n * @param {import('./public.js').Readable<T>} store  - store to make readonly\n * @returns {import('./public.js').Readable<T>}\n */\nexport function readonly(store) {\n\treturn {\n\t\tsubscribe: store.subscribe.bind(store)\n\t};\n}\n\nexport { get_store_value as get };\n","import { writable } from \"svelte/store\";\n// Creates a singly linked list from the given array, using svelte stores for reactivity\nexport function fromArray(array) {\n    let current = writable(null);\n    for (let i = array.length - 1; i >= 0; i--) {\n        current = writable({\n            content: array[i],\n            next: current,\n        });\n    }\n    return current;\n}\n//# sourceMappingURL=list.js.map","import { get, writable } from \"svelte/store\";\nimport { fromArray } from \"./list.js\";\nclass ServerAppState {\n    url;\n    node;\n    constructor(url, nodes) {\n        this.url = writable(new URL(url));\n        this.node = fromArray(nodes);\n    }\n}\nclass ClientAppState extends ServerAppState {\n    hrefMap = {};\n    constructor(url, nodes) {\n        super(url, nodes);\n        this.hrefMap[get(this.url).href] = new Promise(r => r(nodes));\n    }\n    async update(href) {\n        this.url.set(new URL(href));\n        const array = await (this.hrefMap[href] ?? load(href));\n        // this loop replaces the first differentiated node from after onto before\n        // the reason this is done instead of simply replacing the first node is so we don't rerender unnecessary nodes\n        // this allows for data persistence in already rendered nodes\n        let before = this.node;\n        let after = fromArray(array);\n        while (true) {\n            const bval = get(before);\n            const aval = get(after);\n            if (!bval && !aval)\n                break; // both nodes are null - end of list, no diff\n            const bcomp = bval?.content.comp;\n            const acomp = aval?.content.comp;\n            if (bcomp === acomp) { // nodes are same component - pass\n                // neiter bval nor aval can be null at this point - typescript isn't smart enough to figure that out\n                //@ts-ignore\n                before = bval.next;\n                //@ts-ignore\n                after = aval.next;\n            }\n            else { // nodes are different components - replace\n                before.set(aval);\n                break;\n            }\n        }\n    }\n}\nexport const AppState = import.meta.env.SSR ? ServerAppState : ClientAppState;\nexport async function load(href) {\n    const headers = { \"Golte\": \"true\" };\n    const resp = await fetch(href, { headers });\n    const json = await resp.json();\n    for (const entry of [...json.Entries, json.ErrPage]) {\n        // load css\n        for (const css of entry.CSS) {\n            if (document.querySelector(`link[href=\"${css}\"][rel=\"stylesheet\"]`))\n                continue;\n            const link = document.createElement(\"link\");\n            link.href = css;\n            link.rel = \"stylesheet\";\n            document.head.appendChild(link);\n        }\n        // TODO send css as its own field, outside of the array\n    }\n    const promises = json.Entries.map(async (entry) => ({\n        comp: (await import(entry.File)).default,\n        props: entry.Props,\n        errPage: (await import(json.ErrPage.File)).default,\n    }));\n    return await Promise.all(promises);\n}\n//# sourceMappingURL=appstate.js.map","<script>\n    import { Node } from \"./node-wrapper.js\";\n    import { onMount, setContext } from \"svelte\";\n    import { golteContext} from \"./keys.js\";\n    import { get } from \"svelte/store\";\n    import { AppState } from \"./appstate.js\";\n\n    /** @type {import(\"./types.js\").CompState[]} */\n    export let nodes;\n\n    /** @type {import(\"./types.js\").ContextData} */\n    export let contextData;\n\n    const state = new AppState(contextData.URL, nodes);\n    const { node } = state;\n    setContext(golteContext, state);\n\n    onMount(() => {\n        history.replaceState(get(state.url).href, \"\");\n        addEventListener(\"popstate\", async (e) => {\n            if (!e.state) return;\n            await state.update(e.state);\n        });\n    });\n</script>\n\n<!-- #key is needed because csr error handling relies on constructor being called again -->\n{#key $node}\n    {#if $node}\n        <Node node={$node} index={0} />\n    {/if}\n{/key}\n","import { getContext } from \"svelte\";\nimport { golteContext } from \"../../shared/keys.js\";\nfunction getGolteContext() {\n    return getContext(golteContext);\n}\n// This store can only be subscribed to during component initialization.\nexport const url = {\n    subscribe(fn) {\n        return getGolteContext().url.subscribe(fn);\n    }\n};\n//# sourceMappingURL=index.js.map","<script>\n    import { preload } from \"golte\";\n    import { url } from \"golte/stores\";\n</script>\n\n<header>\n    <nav>\n        <ul>\n            <li aria-current={$url.pathname === \"/\" ? \"page\" : undefined}>\n                <a href=\"/\" use:preload>Home</a>\n            </li>\n            <li aria-current={$url.pathname === \"/about\" ? \"page\" : undefined}>\n                <a href=\"/about\" use:preload>About</a>\n            </li>\n            <li aria-current={$url.pathname === \"/contact\" ? \"page\" : undefined}>\n                <a href=\"/contact\" use:preload>Contact</a>\n            </li>\n            <li aria-current={$url.pathname === \"/user/profile\" ? \"page\" : undefined}>\n                <a href=\"/user/profile\" use:preload>Profile</a>\n            </li>\n            <li aria-current={$url.pathname === \"/user/login\" ? \"page\" : undefined}>\n                <a href=\"/user/login\" use:preload>Login</a>\n            </li>\n        </ul>\n    </nav>\n</header>\n\n<main>\n    <slot />\n</main>\n\n<style>\n    main {\n        padding: 20px;\n    }\n\n    ul {\n        margin: 0;\n        height: 60px;\n\n        list-style: none;\n\t\tbackground: #ccddf8;;\n        \n        display: flex;\n        gap: 10px;\n        justify-content: center;\n        align-items: center;\n    }\n\n    li {\n        height: 40px;\n        padding: 0 10px;\n    }\n\n    li[aria-current=\"page\"] {\n        border-bottom: solid 2px orangered;\n\t}\n    \n    a {\n        height: 100%;\n        display: flex;\n        align-items: center;\n        color: inherit;\n        \n        font-family: \"Gill Sans\", sans-serif;;\n        font-weight: 700;\n\t\tfont-size: 0.9rem;\n\t\ttext-decoration: none;\n    }\n\n    a:hover {\n        color: orangered;\n    }\n</style>\n","<script>\n    export let username;\n    export let realname;\n    export let occupation;\n    export let age;\n    export let email;\n    export let site;\n    export let searching;\n</script>\n\n<div class=\"name\">\n    <h2>{realname}</h2>\n    <small>{occupation}</small>\n</div>\n\n<table>\n    <tbody>\n        <tr>\n            <td>Username</td>\n            <td>{username}</td>\n        </tr>\n        <tr>\n            <td>Age</td>\n            <td>{age}</td>\n        </tr>\n        <tr>\n            <td>Email</td>\n            <td>{email}</td>\n        </tr>\n        <tr>\n            <td>Site</td>\n            <td><a href={site}>{site}</a></td>\n        </tr>\n        <tr>\n            <td>Looking for job?</td>\n            <td>{searching ? \"Yes\" : \"No\"}</td>\n        </tr>\n    </tbody>\n</table>\n\n<style>\n    h2 {\n        margin-bottom: 0;\n    }\n\n    .name {\n        padding-bottom: 20px;\n    }\n\n    tr td:first-of-type {\n        font-weight: 700;\n        padding-right: 20px;\n    }\n</style>\n","<script>\n    /** @type {number} */\n    export let status;\n\n    /** @type {string} */\n    export let message;\n</script>\n\n<h1>{status}</h1>\n<p>{message}</p>\n\n<style>\n    p {\n        white-space: pre-wrap;\n    }\n</style>\n","import { default as UntypedRoot } from \"../shared/Root.svelte\";\nimport { handleError } from \"../shared/keys.js\";\nconst Root = UntypedRoot;\n// these variables will be set by vite\n// @ts-ignore\ngolteImports;\n// @ts-ignore\nconst hydrate = golteHydrate;\n// @ts-ignore\nexport const Manifest = golteManifest;\nexport function Render(entries, contextData, errPage) {\n    const serverNodes = [];\n    const clientNodes = [];\n    const stylesheets = new Set();\n    const err = Manifest[errPage];\n    if (!err)\n        throw new Error(`\"${errPage}\" is not a component`);\n    for (const e of entries) {\n        const c = Manifest[e.Comp];\n        if (!c)\n            throw new Error(`\"${e.Comp}\" is not a component`);\n        serverNodes.push({ comp: c.server, props: e.Props, errPage: err.server });\n        clientNodes.push({ comp: `${c.Client}`, props: e.Props, errPage: `${err.Client}` });\n        for (const path of c.CSS) {\n            stylesheets.add(path);\n        }\n    }\n    for (const path of err.CSS) {\n        stylesheets.add(path);\n    }\n    let error;\n    const context = new Map(); // TODO dont use context for this\n    context.set(handleError, (e) => error = e);\n    let { html, head } = Root.render({ nodes: serverNodes, contextData }, { context });\n    for (const path of stylesheets) {\n        head += `\\n<link href=\"${path}\" rel=\"stylesheet\">`;\n    }\n    if (error) {\n        clientNodes[error.index].ssrError = error.props;\n    }\n    html += `\n        <script>\n            (async function () {\n                const target = document.currentScript.parentElement;\n                const { hydrate } = await import(\"${hydrate}\");\n                await hydrate(target, ${stringify(clientNodes)}, ${stringify(contextData)});\n            })();\n        </script>\n    `;\n    return {\n        Head: head,\n        Body: html,\n        HasError: !!error,\n    };\n}\nfunction stringify(object) {\n    return JSON.stringify(object).replace(\"</script>\", \"<\\\\/script>\");\n}\n//# sourceMappingURL=render.js.map"],"names":["css","ClientNode","subscribe","run","url","UntypedRoot","component_0","component_1","component_2","component_3","component_4","component_5","component_6","component_7"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,13,14]}