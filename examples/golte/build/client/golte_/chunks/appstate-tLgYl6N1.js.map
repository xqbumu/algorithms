{"version":3,"mappings":"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","names":["get"],"sources":["file:///opt/src/github.com/xqbumu/algorithms/examples/golte/node_modules/.pnpm/golte@0.0.3_svelte@4.2.9/node_modules/golte/js/shared/keys.js","file:///opt/src/github.com/xqbumu/algorithms/examples/golte/node_modules/.pnpm/svelte@4.2.9/node_modules/svelte/src/runtime/store/index.js","file:///opt/src/github.com/xqbumu/algorithms/examples/golte/node_modules/.pnpm/golte@0.0.3_svelte@4.2.9/node_modules/golte/js/shared/list.js","file:///opt/src/github.com/xqbumu/algorithms/examples/golte/node_modules/.pnpm/golte@0.0.3_svelte@4.2.9/node_modules/golte/js/shared/appstate.js"],"sourcesContent":["export const golteContext = Symbol();\nexport const handleError = Symbol();\n//# sourceMappingURL=keys.js.map","import {\n\trun_all,\n\tsubscribe,\n\tnoop,\n\tsafe_not_equal,\n\tis_function,\n\tget_store_value\n} from '../internal/index.js';\n\nconst subscriber_queue = [];\n\n/**\n * Creates a `Readable` store that allows reading by subscription.\n *\n * https://svelte.dev/docs/svelte-store#readable\n * @template T\n * @param {T} [value] initial value\n * @param {import('./public.js').StartStopNotifier<T>} [start]\n * @returns {import('./public.js').Readable<T>}\n */\nexport function readable(value, start) {\n\treturn {\n\t\tsubscribe: writable(value, start).subscribe\n\t};\n}\n\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n *\n * https://svelte.dev/docs/svelte-store#writable\n * @template T\n * @param {T} [value] initial value\n * @param {import('./public.js').StartStopNotifier<T>} [start]\n * @returns {import('./public.js').Writable<T>}\n */\nexport function writable(value, start = noop) {\n\t/** @type {import('./public.js').Unsubscriber} */\n\tlet stop;\n\t/** @type {Set<import('./private.js').SubscribeInvalidateTuple<T>>} */\n\tconst subscribers = new Set();\n\t/** @param {T} new_value\n\t * @returns {void}\n\t */\n\tfunction set(new_value) {\n\t\tif (safe_not_equal(value, new_value)) {\n\t\t\tvalue = new_value;\n\t\t\tif (stop) {\n\t\t\t\t// store is ready\n\t\t\t\tconst run_queue = !subscriber_queue.length;\n\t\t\t\tfor (const subscriber of subscribers) {\n\t\t\t\t\tsubscriber[1]();\n\t\t\t\t\tsubscriber_queue.push(subscriber, value);\n\t\t\t\t}\n\t\t\t\tif (run_queue) {\n\t\t\t\t\tfor (let i = 0; i < subscriber_queue.length; i += 2) {\n\t\t\t\t\t\tsubscriber_queue[i][0](subscriber_queue[i + 1]);\n\t\t\t\t\t}\n\t\t\t\t\tsubscriber_queue.length = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {import('./public.js').Updater<T>} fn\n\t * @returns {void}\n\t */\n\tfunction update(fn) {\n\t\tset(fn(value));\n\t}\n\n\t/**\n\t * @param {import('./public.js').Subscriber<T>} run\n\t * @param {import('./private.js').Invalidator<T>} [invalidate]\n\t * @returns {import('./public.js').Unsubscriber}\n\t */\n\tfunction subscribe(run, invalidate = noop) {\n\t\t/** @type {import('./private.js').SubscribeInvalidateTuple<T>} */\n\t\tconst subscriber = [run, invalidate];\n\t\tsubscribers.add(subscriber);\n\t\tif (subscribers.size === 1) {\n\t\t\tstop = start(set, update) || noop;\n\t\t}\n\t\trun(value);\n\t\treturn () => {\n\t\t\tsubscribers.delete(subscriber);\n\t\t\tif (subscribers.size === 0 && stop) {\n\t\t\t\tstop();\n\t\t\t\tstop = null;\n\t\t\t}\n\t\t};\n\t}\n\treturn { set, update, subscribe };\n}\n\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * https://svelte.dev/docs/svelte-store#derived\n * @template {import('./private.js').Stores} S\n * @template T\n * @overload\n * @param {S} stores - input stores\n * @param {(values: import('./private.js').StoresValues<S>, set: (value: T) => void, update: (fn: import('./public.js').Updater<T>) => void) => import('./public.js').Unsubscriber | void} fn - function callback that aggregates the values\n * @param {T} [initial_value] - initial value\n * @returns {import('./public.js').Readable<T>}\n */\n\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * https://svelte.dev/docs/svelte-store#derived\n * @template {import('./private.js').Stores} S\n * @template T\n * @overload\n * @param {S} stores - input stores\n * @param {(values: import('./private.js').StoresValues<S>) => T} fn - function callback that aggregates the values\n * @param {T} [initial_value] - initial value\n * @returns {import('./public.js').Readable<T>}\n */\n\n/**\n * @template {import('./private.js').Stores} S\n * @template T\n * @param {S} stores\n * @param {Function} fn\n * @param {T} [initial_value]\n * @returns {import('./public.js').Readable<T>}\n */\nexport function derived(stores, fn, initial_value) {\n\tconst single = !Array.isArray(stores);\n\t/** @type {Array<import('./public.js').Readable<any>>} */\n\tconst stores_array = single ? [stores] : stores;\n\tif (!stores_array.every(Boolean)) {\n\t\tthrow new Error('derived() expects stores as input, got a falsy value');\n\t}\n\tconst auto = fn.length < 2;\n\treturn readable(initial_value, (set, update) => {\n\t\tlet started = false;\n\t\tconst values = [];\n\t\tlet pending = 0;\n\t\tlet cleanup = noop;\n\t\tconst sync = () => {\n\t\t\tif (pending) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcleanup();\n\t\t\tconst result = fn(single ? values[0] : values, set, update);\n\t\t\tif (auto) {\n\t\t\t\tset(result);\n\t\t\t} else {\n\t\t\t\tcleanup = is_function(result) ? result : noop;\n\t\t\t}\n\t\t};\n\t\tconst unsubscribers = stores_array.map((store, i) =>\n\t\t\tsubscribe(\n\t\t\t\tstore,\n\t\t\t\t(value) => {\n\t\t\t\t\tvalues[i] = value;\n\t\t\t\t\tpending &= ~(1 << i);\n\t\t\t\t\tif (started) {\n\t\t\t\t\t\tsync();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t() => {\n\t\t\t\t\tpending |= 1 << i;\n\t\t\t\t}\n\t\t\t)\n\t\t);\n\t\tstarted = true;\n\t\tsync();\n\t\treturn function stop() {\n\t\t\trun_all(unsubscribers);\n\t\t\tcleanup();\n\t\t\t// We need to set this to false because callbacks can still happen despite having unsubscribed:\n\t\t\t// Callbacks might already be placed in the queue which doesn't know it should no longer\n\t\t\t// invoke this derived store.\n\t\t\tstarted = false;\n\t\t};\n\t});\n}\n\n/**\n * Takes a store and returns a new one derived from the old one that is readable.\n *\n * https://svelte.dev/docs/svelte-store#readonly\n * @template T\n * @param {import('./public.js').Readable<T>} store  - store to make readonly\n * @returns {import('./public.js').Readable<T>}\n */\nexport function readonly(store) {\n\treturn {\n\t\tsubscribe: store.subscribe.bind(store)\n\t};\n}\n\nexport { get_store_value as get };\n","import { writable } from \"svelte/store\";\n// Creates a singly linked list from the given array, using svelte stores for reactivity\nexport function fromArray(array) {\n    let current = writable(null);\n    for (let i = array.length - 1; i >= 0; i--) {\n        current = writable({\n            content: array[i],\n            next: current,\n        });\n    }\n    return current;\n}\n//# sourceMappingURL=list.js.map","import { get, writable } from \"svelte/store\";\nimport { fromArray } from \"./list.js\";\nclass ServerAppState {\n    url;\n    node;\n    constructor(url, nodes) {\n        this.url = writable(new URL(url));\n        this.node = fromArray(nodes);\n    }\n}\nclass ClientAppState extends ServerAppState {\n    hrefMap = {};\n    constructor(url, nodes) {\n        super(url, nodes);\n        this.hrefMap[get(this.url).href] = new Promise(r => r(nodes));\n    }\n    async update(href) {\n        this.url.set(new URL(href));\n        const array = await (this.hrefMap[href] ?? load(href));\n        // this loop replaces the first differentiated node from after onto before\n        // the reason this is done instead of simply replacing the first node is so we don't rerender unnecessary nodes\n        // this allows for data persistence in already rendered nodes\n        let before = this.node;\n        let after = fromArray(array);\n        while (true) {\n            const bval = get(before);\n            const aval = get(after);\n            if (!bval && !aval)\n                break; // both nodes are null - end of list, no diff\n            const bcomp = bval?.content.comp;\n            const acomp = aval?.content.comp;\n            if (bcomp === acomp) { // nodes are same component - pass\n                // neiter bval nor aval can be null at this point - typescript isn't smart enough to figure that out\n                //@ts-ignore\n                before = bval.next;\n                //@ts-ignore\n                after = aval.next;\n            }\n            else { // nodes are different components - replace\n                before.set(aval);\n                break;\n            }\n        }\n    }\n}\nexport const AppState = import.meta.env.SSR ? ServerAppState : ClientAppState;\nexport async function load(href) {\n    const headers = { \"Golte\": \"true\" };\n    const resp = await fetch(href, { headers });\n    const json = await resp.json();\n    for (const entry of [...json.Entries, json.ErrPage]) {\n        // load css\n        for (const css of entry.CSS) {\n            if (document.querySelector(`link[href=\"${css}\"][rel=\"stylesheet\"]`))\n                continue;\n            const link = document.createElement(\"link\");\n            link.href = css;\n            link.rel = \"stylesheet\";\n            document.head.appendChild(link);\n        }\n        // TODO send css as its own field, outside of the array\n    }\n    const promises = json.Entries.map(async (entry) => ({\n        comp: (await import(entry.File)).default,\n        props: entry.Props,\n        errPage: (await import(json.ErrPage.File)).default,\n    }));\n    return await Promise.all(promises);\n}\n//# sourceMappingURL=appstate.js.map"],"file":"golte_/chunks/appstate-tLgYl6N1.js"}